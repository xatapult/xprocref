<?xml version="1.0" encoding="UTF-8"?>
<step name="http-request" version-idref="v30" category-idrefs="standard-steps env" short-description="Interact using HTTP (or related protocols)"
  required="true" publish="true" href-specification="{$BASELINK-STANDARD-STEPS-V30}#c.http-request"
  xsi:schemaLocation="http://www.xtpxlib.nl/ns/xprocref ../../../xsd/xprocref.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns="http://www.xtpxlib.nl/ns/xprocref">

  <!-- ======================================================================= -->

  <signature>

    <input port="source" content-types="any" sequence="true" primary="true">
      <description>
        <para>Document(s) used in constructing the request body.</para>
        <para>By default, source documents are used for HTTP methods that require a body (for instance <code>POST</code>) only. If the HTTP method
          does not specify a body (for instance <code>GET</code>), any documents appearing on the <port>source</port> port are ignored. You can
          control this behaviour with the <code>send-body-anyway</code> parameter (see <xref linkend="request-parameters"/>).</para>
      </description>
    </input>

    <output port="result" primary="true" content-types="any" sequence="true">
      <description>
        <para>The request result document(s). See <xref linkend="http-report"/>.</para>
      </description>
    </output>

    <output port="report" content-types="application/json" primary="false" sequence="true">
      <description>
        <para>A map containing information about the response. See <xref linkend="http-report"/>.</para>
      </description>
    </output>

    <option name="href" as="xs:anyURI" required="true">
      <description>
        <para>The URI to use for the request.</para>
      </description>
    </option>

    <option name="method" as="xs:string?" select="'GET'" required="false">
      <description>
        <para>The HTTP request method to use for the request. Its value is converted to upper-case.</para>
        <para>Any implementations must support the HTTP methods <code>GET</code> (default), <code>POST</code>, <code>PUT</code>, <code>DELETE</code>,
          and <code>HEAD</code>. Whether any other methods are supported is implementation-defined and therefore dependent on the XProc processor
          used. </para>
      </description>
    </option>

    <option name="serialization" as="map(xs:QName,item()*)?" required="false">
      <description>
        <para>Before the document(s) on the <port>source</port> port are used, they are first serialized (as if written to disk). This option can
          supply a map with <link xlink:href="https://www.w3.org/TR/xslt-xquery-serialization-31/" role="newpage">serialization properties</link>,
          controlling this serialization.</para>
        <xi:include href="../../text-fragments/merge-serialization-properties.xml"/>
      </description>
    </option>

    <option name="headers" as="map(xs:string, xs:string)?" required="false">
      <description>
        <para>A map containing the request headers. Each map key is used as a header name and the value associated is used as the header value.</para>
        <para>There are some special rules regarding the request headers, see <xref linkend="request-header-specification"/>.</para>
        <para>Request headers can influence the construction of the request. See <xref linkend="request-header-usage"/>.</para>
      </description>
    </option>

    <option name="auth" as="map(xs:string, item()+)?" required="false">
      <description>
        <para>Information for the authentication of the request (in other words: about &#x201c;logging in&#x201d;). See <xref
            linkend="request-athentication"/></para>
      </description>
    </option>
    <option name="parameters" as="map(xs:QName, item()*)?" required="false">
      <description>
        <para>A map with parameters for fine-tuning the construction of the request and/or the handling of the server response. See <xref
            linkend="request-parameters"/>.</para>
      </description>
    </option>

    <option name="assert" as="xs:string" select="'.?status-code lt 400'" required="false">
      <description>
        <para>Any request can fail, but what exactly failure is depends on the expectations of the receiver. This option takes an XPath expression
          that can inspect the request results. If the result of this expression (executed after a response is received) is <code>false</code>,
          dynamic error <step-error-ref code="XC0126"/> is raised. See <xref linkend="assert-request-fails"/></para>
      </description>
    </option>

  </signature>

  <!-- ======================================================================= -->

  <summary>
    <para>The <step/> step allows pipelines to interact with resources (for instance websites) over HTTP or related protocols.</para>
  </summary>

  <!-- ======================================================================= -->

  <description>

    <para>The <step/> allows you to send requests to some server and receive their response. You could use this, for instance, to access REST or other
      services on the web. Another use case is to have your pipeline play &#x201c;web browser&#x201d;: get the contents of a web page and interpret
      this or fill in some page with a form in the background. Although the step is generic, it will probably be used most (exclusively?) using the
      HTTP(S) protocol, so we&#x2019;ll concentrate on this. </para>

    <para>The HTTP(s) protocol is rather complex and, to support this, <step/> is also complex. As a result of this, the description of <step/> is
      long and may appear intimidating to users who are not familiar with the finer details of the HTTP(S) protocol. Luckily, simple interactions,
      like just requesting a single web page, are easy (see <example-ref idref="basic-usage"/>) Let&#x2019;s take it step by step (if there are parts
      you don't understand, chances are you don't need them). The HTTP(S) protocol itself is not explained, if you need more information about this, a
      good place to start would be on <link xlink:href="https://en.wikipedia.org/wiki/HTTP" role="newpage">Wikipedia</link>.</para>

    <orderedlist>
      <listitem>
        <para>The <step/> step first constructs a request:</para>
        <itemizedlist>
          <listitem>
            <para>An HTTP(S) request is always to some URI (like <link xlink:href="https://xprocref.org/" role="newpage"
                  ><code>https://xprocref.org/</code></link>). You must specify this URI using the mandatory <option>href</option> option.</para>
          </listitem>
          <listitem>
            <para>An HTTP(S) request has a method. Usual values are <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, and
                <code>HEAD</code>. You can specify this using the <option>method</option> option. Its default value is <code>GET</code>.</para>
          </listitem>
          <listitem>
            <para>An HTTP(S) request has request headers: name/value pairs that contain additional information for the server. The main source for
              specifying request headers is the <option>headers</option> option. Some special handling applies, see <xref
                linkend="request-header-specification"/>.</para>
          </listitem>
          <listitem>
            <para>Once the request headers are known, some of this information is used by <step/> for additional purposes, like determining the
              transfer encoding. See <xref linkend="request-header-usage"/> for more information.</para>
          </listitem>
          <listitem>
            <para>Any documents that must accompany the request can be supplied on the <port>source</port> port.</para>
          </listitem>
          <listitem>
            <para>Some interactions require authorization (&#x201c;logging in&#x201d;). This is usually specified with the <option>auth</option>
              option. See <xref linkend="request-athentication"/> for more information.</para>
          </listitem>
          <listitem>
            <para>It is possible to construct multipart request: requests where multiple documents are sent at once. See <xref linkend="multipart"/>
              for more information.</para>
          </listitem>
          <listitem>
            <para>Further fine-tuning of the request is done using parameters specified in the <option>parameters</option> option. See <xref
                linkend="request-parameters"/> for more information.</para>
          </listitem>
        </itemizedlist>
      </listitem>
      <listitem>
        <para>The request is sent to the server and <step/> waits for a response. How long the step will wait before giving up can be specified using
          parameters specified in the <option>parameters</option> option. See <xref linkend="request-parameters"/> for more information. </para>
      </listitem>
      <listitem>
        <para>A response is received an interpreted:</para>
        <itemizedlist>
          <listitem>
            <para>Whether a response is considered successful can be specified using the <option>assert</option> option. If not, error <step-error-ref
                code="XC0126"/> is raised. See <xref linkend="assert-request-fails"/> for more information.</para>
          </listitem>
          <listitem>
            <para>Further fine-tuning of the interpretation of the response is done using parameters specified in the <option>parameters</option>
              option. See <xref linkend="request-parameters"/> for more information.</para>
          </listitem>
          <listitem>
            <para>Any documents contained in the response appear on the <port>result</port> port.</para>
          </listitem>
          <listitem>
            <para>Additional information about the response (its response headers, status code, etc.) appears on the <port>report</port> port, as a
              map. See <xref linkend="http-report"/> for more information.</para>
          </listitem>
        </itemizedlist>
      </listitem>

    </orderedlist>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <section xml:id="request-header-specification">
      <title>Specifying request headers</title>

      <para>An HTTP request has <emphasis>request headers</emphasis>: name/value pairs containing additional information for the server. See for
        instance <link xlink:href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields" role="newpage">Wikipedia</link> for an overview.</para>

      <para>The main source for <step/> for constructing HTTP request headers is its <option>headers</option> option (see <example-ref
          idref="viewing-rh"/>). </para>

      <para>If a <emphasis>single</emphasis> document appears on the <port>source</port> port and we&#x2019;re <emphasis>not</emphasis> constructing a
        multipart message, special rules apply:</para>
      <itemizedlist>

        <listitem>
          <para>If the (single) document appearing on the <port>source</port> port:</para>
          <itemizedlist>
            <listitem>
              <para>is an XML, HTML or text document,</para>
            </listitem>
            <listitem>
              <para><emphasis>and</emphasis> has a <option>serialization</option> document-property,</para>
            </listitem>
            <listitem>
              <para><emphasis>and</emphasis> this <option>serialization</option> document-property has an entry called <code>encoding</code>,</para>
            </listitem>
          </itemizedlist>
          <para>a <code>charset</code> is appended to the created <code>content-type</code> header of the HTTP request (for more information about
            this <code>charset</code> parameter, see for instance <link xlink:href="https://www.w3.org/International/articles/http-charset/index"
              role="newpage">here</link>).</para>
        </listitem>

        <listitem>
          <para>Any document-properties of the (single) document appearing on the <port>source</port> port that are in the
              <code>http://www.w3.org/ns/xproc-http</code> namespace will be added as request header, using their local name (their name without
            namespace) as the request header name.</para>
          <para>For a request parameter specified both in a document-property and in the map provided to the <option>headers</option> option, the one
            in the <option>headers</option> option takes precedence. This comparison is case-<emphasis>in</emphasis>sensitive.</para>
        </listitem>

      </itemizedlist>

      <para>When constructing a multipart message, not only the request itself but also its separate documents can have request headers. For more
        information on how this can be specified see <xref linkend="multipart"/>.</para>

    </section>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <section xml:id="request-header-usage">
      <title>Usage of request headers</title>

      <para>Once the request headers are constructed (see <xref linkend="request-header-specification"/>), some of these are used for additional
        purposes:</para>

      <itemizedlist>

        <listitem>
          <para>If the value of the <code>content-type</code> request header starts with <code>multipart/</code>, a multipart request is constructed.
            (regardless of the number of documents appearing on the <port>source</port> port). See <xref linkend="multipart"/>.</para>
        </listitem>

        <listitem>
          <para>For non multipart messages, it is possible to override the media type (<property>content-type</property> document-property) of the
            body document. If a single document appears on the <port>source</port> port, we&#x2019;re not constructing a multipart message and a
              <code>content-type</code> request header is specified, the value of the <code>content-type</code> request header overrides the value of
            the <property>content-type</property> document-property.</para>
        </listitem>

        <listitem>
          <para>If a <code>transfer-encoding</code> request header is present, the request is sent using that particular encoding (for more
            information about transfer encodings see <link xlink:href="https://www.rfc-editor.org/rfc/rfc9112#section-6.1" role="newpage"
            >here</link>). Examples of values are <code>chunked</code>, <code>compress</code> or <code>gzip</code>.</para>
        </listitem>

        <listitem>
          <para>How authorization (&#x201c;logging in&#x201d;) is done, is specified using the <code>authorization</code> request header. However, the
            <step/> step also has an <option>auth</option> option for specifying this (see <xref linkend="request-athentication"/>). If this option is
            specified, the <code>authorization</code> request header, if present, is ignored. Instead, the value of the <code>authorization</code>
            request header is determined exclusively by the value of the <option>auth</option> option.</para>
        </listitem>

      </itemizedlist>

    </section>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <section xml:id="request-athentication">
      <title>Request authentication</title>

      <para>Information about the authorization of a request (&#x201c;logging in&#x201d;) is sent to the server with the <code>authorization</code>
        request header. Experienced users could construct this request header themselves and add it to the step <option>headers</option> option (or
        use a document-property). However, in most cases, it is easier to pass the authorization information using the <option>auth</option> option
        and have <step/> construct the <code>authorization</code> request header for you. If you use the <option>auth</option> option, any
          <code>authorization</code> request header passed in some other way is ignored.</para>

      <para>The <option>auth</option> option contains the credentials (username, password, etc.) of the client and specifies what authentication
        method is used. It must be a map with string (<code>xs:string</code>) type keys. The following standard keys are defined:</para>

      <table role="nonumber">
        <title/>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>
                <para>Key</para>
              </entry>
              <entry>
                <para>Value data type</para>
              </entry>
              <entry>
                <para>Description</para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  <code>username</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:string</code>
                </para>
              </entry>
              <entry>
                <para> The username for the request. </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>password</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:string</code>
                </para>
              </entry>
              <entry>
                <para> The password associated with the username. </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>auth-method</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:string</code>
                </para>
              </entry>
              <entry>
                <para>Specifies the authentication method to use. Standard values are <code>Basic</code> or <code>Digest</code> (see <link
                    xlink:href="https://www.rfc-editor.org/info/rfc2617" role="newpage">here</link> for further information). Whether other
                  authorization methods are supported and how to specify these is implementation-defined and therefore dependent on the XProc
                  processor used.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>send-authorization</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:boolean</code>
                </para>
              </entry>
              <entry>
                <para>This controls the &#x201c;authorization challenge&#x201d;:</para>
                <itemizedlist>
                  <listitem>
                    <para>If this key is absent or its value is not <code>true</code>, a first request is sent <emphasis>without</emphasis>
                      authorization information. If the server subsequently requests it, the request is resent <emphasis>with</emphasis> authorization
                      information. </para>
                  </listitem>
                  <listitem>
                    <para>If this key&#x2019;s value is <code>true</code>, the first request immediately contains the authorization
                      information.</para>
                  </listitem>
                </itemizedlist>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>If an authorization fails, the request is not retried.</para>
      <para>Any other key/value pairs for the <option>auth</option> option map are implementation-defined and therefore dependent on the XProc
        processor used.</para>

    </section>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <section xml:id="request-parameters">
      <title>Parameters</title>

      <para>The <option>parameters</option> option provides information for fine tuning the construction of the request and/or handling the response.
        It must be a map with string (<code>xs:string</code>) type keys. The following standard keys are defined:</para>

      <table role="nonumber">
        <title/>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>
                <para>Key</para>
              </entry>
              <entry>
                <para>Value data type</para>
              </entry>
              <entry>
                <para>Description</para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  <code>override-content-type</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:string</code>
                </para>
              </entry>
              <entry>
                <para>The XProc processor must know how to interpret the body of a server response, its data type. Normally this is done by looking at
                  the <code>content-type</code> response header. If this, for instance, is set to <code>application/xml</code>, the response body is
                  interpreted as an XML document. Of course this must succeed, if not, error <step-error-ref code="XC0030"/> is raised. </para>
                <para>If you specify an <code>override-content-type</code> parameter, its value is used instead of that in the
                    <code>content-type</code> response header.</para>
                <para>The information about the <code>content-type</code> response header that appears on the <port>report</port> port (see <xref
                    linkend="http-report"/>) is <emphasis>not</emphasis> changed and still reflects the actual value received from the server.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>http-version</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:string</code>
                </para>
              </entry>
              <entry>
                <para>Specifies the HTTP version to use for the request. Its default value is implementation-defined and therefore depends on the
                  XProc processor used. Most probably it will be <code>1.1</code>.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>accept-multipart</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:boolean</code>
                </para>
              </entry>
              <entry>
                <para>If this parameter is present and has the value <code>false</code>, any multipart response will result in raising error
                    <step-error-ref code="XC0125"/>. You can use this to prevent unexpected multipart responses wreak havoc in your pipeline. </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>override-content-encoding</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:string</code>
                </para>
              </entry>
              <entry>
                <para>The XProc processor must know how the encoding of a server response (for instance: <code>utf-8</code>). Normally this is done by
                  looking at the <code>content-encoding</code> response header. If you specify an <code>override-content-encoding</code> parameter,
                  its value is used instead of that in the <code>content-encoding</code> response header.</para>
                <para>The information about the <code>content-encoding</code> response header that appears on the <port>report</port> port (see <xref
                    linkend="http-report"/>) is <emphasis>not</emphasis> changed and still reflects the actual value received from the server.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>permit-expired-ssl-certificate</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:boolean</code>
                </para>
              </entry>
              <entry>
                <para>If this parameter is present and has the value <code>true</code>, <step/> does <emphasis>not</emphasis> reject a response where
                  the server provides an expired SSL certificate.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>permit-untrusted-ssl-certificate</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:boolean</code>
                </para>
              </entry>
              <entry>
                <para>If this parameter is present and has the value <code>true</code>, <step/> does <emphasis>not</emphasis> reject a response where
                  the server provides an SSL certificate which is not trusted, for example, because the certificate authority (CA) is unknown.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>follow-redirect</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:integer</code>
                </para>
              </entry>
              <entry>
                <para>Sometimes a server responds with a <emphasis>redirect</emphasis>, meaning something like &#x201c;please repeat the request to
                  this different URI&#x201d;. The <code>follow-redirect</code> parameter tells the XProc processor what to do when a redirect is
                  received: </para>
                <itemizedlist>
                  <listitem>
                    <para>If its value is <code>0</code>, redirects are not followed.</para>
                  </listitem>
                  <listitem>
                    <para>If its value is <code>-1</code>, redirects are followed indefinitely.</para>
                  </listitem>
                  <listitem>
                    <para>If its value is <emphasis>positive</emphasis>, at most this number of subsequent redirects are followed.</para>
                  </listitem>
                </itemizedlist>
                <para>The default behaviour, when the <code>follow-redirect</code> parameter is not present, is implementation-defined and therefore
                  dependent on the XProc processor used.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>timeout</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:integer</code>
                </para>
              </entry>
              <entry>
                <para>Specifies the number of seconds to wait for a response. If no response is received after approximately this number of seconds,
                  the request is terminated and HTTP status <code>408</code> is assumed. </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>fail-on-timeout</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:boolean</code>
                </para>
              </entry>
              <entry>
                <para>Sometimes a request results in a timeout. This can either happen by receiving a response with HTTP status <code>408</code> or
                  because the number of seconds specified in the <code>timeout</code> parameter is exceeded. If a <code>fail-on-timeout</code>
                  parameter is present and has the value <code>true</code>, this will result in raising error <step-error-ref code="XC0078"/>.</para>
                <para>This might be confusing, because XProc also has a <code>[p:]timeout</code> attribute, useable on all steps, that tells the XProc
                  processor how long a step invocation is allowed to take (also specified in seconds). What happens depends on whatever comes
                  first:</para>
                <itemizedlist>
                  <listitem>
                    <para>If the number of seconds specified in the <code>[p:]timeout</code> attribute is exceeded, error <code>XD0053</code> is
                      raised (a generic timeout error).</para>
                    <para>Be careful when you want to use this: whether a processor supports timeouts using the <code>[p:]timeout</code> attribute,
                      and if it does, how precisely and precisely how the execution time of a step is measured, is implementation-defined and
                      therefore dependent on the XProc processor used.</para>
                  </listitem>
                  <listitem>
                    <para>If <code>fail-on-timeout</code> is <code>true</code> and a timeout happens, error <step-error-ref code="XC0078"/> is
                      raised.</para>
                  </listitem>
                </itemizedlist>

              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>status-only</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:boolean</code>
                </para>
              </entry>
              <entry>
                <para>If this parameter is present and its value is <code>true</code>, it indicates that the pipeline author is interested in the
                  response code only. The <port>result</port> port will not emit anything. The map on the <port>report</port> port will return an
                  empty map as value of its <code>headers</code> entry.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>suppress-cookies</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:boolean</code>
                </para>
              </entry>
              <entry>
                <para>If this parameter is present and its value is <code>true</code>, no cookies are sent with the request.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>send-body-anyway</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:boolean</code>
                </para>
              </entry>
              <entry>
                <para>By default, whether a body is sent with the request depends on the HTTP method used (the value of the <option>method</option>
                  option). For instance, the <code>GET</code> method does not specify a body. When the <code>GET</code> method is used, by default any
                  document(s) on the <port>source</port> port are ignored.</para>
                <para>When the <code>send-body-anyway</code> parameter is present and its value is <code>true</code>, a request body will always be
                  constructed, even if the HTTP method used does not specify this.</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Any other key/value pairs for the <option>parameters</option> option map are implementation-defined and therefore dependent on the XProc
        processor used.</para>

    </section>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <section xml:id="http-report">
      <title>The response result and report</title>

      <para>When an answer is received from the server, document(s) in the response body will appear as document(s) on the <port>result</port> port.
        Each document will be parsed according to its content-type. You can override this behaviour using the <code>override-content-type</code>
        parameter (see <xref linkend="request-parameters"/>).</para>

      <para>In case of a multipart response, each part will become a separate document appearing on the <port>result</port> port. Any response headers
        associated with a specific part are added to the document-properties of the resulting document.</para>

      <para>The <port>report</port> port always returns a map with the following keys/entries:</para>

      <table role="nonumber">
        <title/>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>
                <para>Key</para>
              </entry>
              <entry>
                <para>Value data type</para>
              </entry>
              <entry>
                <para>Description</para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  <code>
                    <code>status-code</code>
                  </code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:integer</code>
                </para>
              </entry>
              <entry>
                <para>The HTTP status code for the request, for instance <code>200</code> (success) or <code>404</code> (failure).</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>
                    <code>base-uri</code>
                  </code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:anyURI</code>
                </para>
              </entry>
              <entry>
                <para>The URI of the request.</para>
                <para>In case of HTTP redirection, this value may be different from the original request URI.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>
                    <code>headers</code>
                  </code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>map(xs:string, xs:string)</code>
                </para>
              </entry>
              <entry>
                <para>The HTTP headers returned for the request. Header names are in lower-case. The map may be empty.</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>



    </section>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <section xml:id="assert-request-fails">
      <title>Asserting the request status</title>
      <para>Any request can fail, but what exactly failure is depends on the expectations of the receiver. The <code>assert</code> option of <step/>
        takes an XPath expression that inspects the request results:</para>
      <itemizedlist>
        <listitem>
          <para>It must contain a valid (boolean) XPath expression.</para>
        </listitem>
        <listitem>
          <para>This expression will be executed when a response is received.</para>
        </listitem>
        <listitem>
          <para>The context item when executing the expression is the map that also appears on the <port>report</port> port (see <xref
              linkend="http-report"/>).</para>
        </listitem>
        <listitem>
          <para>If the expression evaluates to <code>false</code>, the request is considered failed and error <step-error-ref code="XC0126"/> is
            raised.</para>
        </listitem>
        <listitem>
          <para>If the expression evaluates to <code>true</code>, the request is considered successful. No error is raised.</para>
        </listitem>
      </itemizedlist>

      <para>The default value for the <option>assert</option> option is <code>.?status-code lt 400</code>. Since the context item is the map on the
          <port>report</port> port, the dot operator <code>.</code> here refers to this map. The <code>.?status-code</code> part is one of the ways to
        access a map entry (another way to write this is <code>.('status-code')</code>). The referred map entry contains the received (integer) HTTP
        status code. According to its default interpretation, when less than <code>400</code>, the response is considered a success. If it&#x2019;s
        greater than or equal to <code>400</code>, it is considered a failure and error <step-error-ref code="XC0126"/> is raised.</para>

    </section>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <section xml:id="multipart">
      <title>Multipart requests</title>

      <para>Multipart requests combine one or more sets of data into a single HTTP request. You use this for file uploads and/or transferring data of
        several types in one go. For instance, a web page that allows you to upload several images could use a single multipart request to sent all
        these images to the server. For more information, see for instance <link xlink:href="https://en.wikipedia.org/wiki/MIME#Multipart_messages"
          role="newpage">Wikipedia</link> or the <link xlink:href="https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html" role="newpage">W3C
          multipart protocol description</link>.</para>

      <para>The <step/> step constructs a multipart request if one or both of the following conditions is met:</para>
      <itemizedlist>
        <listitem>
          <para>Multiple documents appear on the <port>source</port> port.</para>
        </listitem>
        <listitem>
          <para>The <code>content-type</code> request header (see <xref linkend="request-header-specification"/>) starts with <code>multipart/</code>.
          </para>
        </listitem>
      </itemizedlist>

      <para>If no specific <code>content-type</code> request header is specified and the <port>source</port> receives multiple documents, the content
        type is set to <code>multipart/mixed</code>.</para>

      <para>Multipart request must have a <emphasis>boundary marker</emphasis>: a string of characters that is inserted in between the message parts.
        This is critical, because this marker must <emphasis>not</emphasis> appear anywhere in the data itself. If it does, the request is considered
        malformed. The boundary marker as used by <step/> is constructed as follows:</para>
      <itemizedlist>
        <listitem>
          <para>If the <code>content-type</code> request header contains a boundary parameter, this is used.</para>
          <para>For instance, by setting the <code>content-type</code> to <code>multipart/mixed; boundary=gc0p4Jq0M2Yt08jU534c0p</code>, the boundary
            marker becomes <code>--gc0p4Jq0M2Yt08jU534c0p</code> (the two hyphens in front are prescribed by the protocol).</para>
        </listitem>
        <listitem>
          <para>If this is not the case, the boundary marker is implementation-defined and therefore dependent on the XProc processor used.
            Unfortunately, there is no guarantee this boundary marker does not appear in the data itself (which would make the request
            malformed).</para>
        </listitem>
      </itemizedlist>

      <para>When constructing the multipart message, each document on the <port>source</port> port is serialized (as if written to disk). If a
        document has a <property>serialization</property> document-property, this is used to determine the serialization format.</para>

      <para>The separate documents in a multipart message can have request headers on their own. Examples of often used headers are <code>id</code>,
          <code>description</code> and <code>disposition</code>. Document-properties of documents on the <port>source</port> port that are in the
          <code>http://www.w3.org/ns/xproc-http</code> namespace will be used to construct request headers for that particular document, using their
        local name (their name without namespace) as the request header name.</para>

    </section>

  </description>

  <!-- ======================================================================= -->

  <detail>
    <para>A relative value for the <option>href</option> option is resolved against the base URI of the element on which this option is specified. In
      most cases this will be the static base URI of your pipeline (the path where the XProc source containing the <step/> is stored). This is very
      probably not what you want. </para>
  </detail>

  <detail>
    <para>HTTP request header names are case-insensitive, but keys in maps are not. This means that you could specify the same request header multiple
      times in the <option>headers</option> option. For instance as <code>Content-Type</code> and <code>content-type</code>. If that happens, error
        <step-error-ref code="XC0127"/> is raised.</para>
  </detail>

  <detail>
    <para>When constructing multipart requests (see <xref linkend="multipart"/>): multiple documents on the <port>source</port> port combined with a
        <code>content-type</code> header that does <emphasis>not</emphasis> start with <code>multipart/</code> raises error <step-error-ref
        code="XC0133"/>.</para>
  </detail>

  <!-- ======================================================================= -->

  <example title="Basic usage" id="basic-usage">

    <para>The following example:</para>
    <itemizedlist>
      <listitem>
        <para>Uses <step/> to ask for the home page of the <link xlink:href="https://xprocref.org" role="newpage">https://xprocref.org</link> website,
          just like a web browser. This fires an HTTPS <code>GET</code> request and waits for the answer.</para>
        <para>Notice that we have to supply a value for the <port>source</port> port, even if we don&#x2019;t need it. In this case we simply set it
          to <tag>p:empty</tag>.</para>
      </listitem>
      <listitem>
        <para>We strip the resulting HTML page to just its <tag>head</tag> (otherwise the result would be too big to display).</para>
      </listitem>
    </itemizedlist>

    <xproc-example href="../../examples/http-request/http-request-01.xpl">
      <result-header>
        <para>Resulting HTML fragment:</para>
      </result-header>
    </xproc-example>

  </example>

  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

  <example title="Viewing the request headers" id="viewing-rh">

    <para>When we want to see what <step/> sends as request headers, we need some developer website that tells us what the request headers are. There
      is such a server by <link xlink:href="https://beeceptor.com/" role="newpage">Beeceptor</link>: send some HTTP request to <link
        xlink:href="https://echo.free.beeceptor.com" role="newpage"><code>https://echo.free.beeceptor.com</code></link> and what you receive is a JSON
      message containing information about your request.</para>

    <para>Sending a simple <code>GET</code> request to this URI returns (results vary depending on your IP, operating system, browser, etc.): </para>
    <example-doc href="../../examples/http-request/http-request-02-output.json"/>

    <para>The following example sends a simple HTTPS request to this server and uses the resulting JSON to construct an XML document showing the HTTP
      request headers sent:</para>
    <itemizedlist>
      <listitem>
        <para>The invocation of <step/> just sends a <code>GET</code> request to <link xlink:href="https://echo.free.beeceptor.com" role="newpage"
              ><code>https://echo.free.beeceptor.com</code></link>. </para>
      </listitem>
      <listitem>
        <para>The result is a JSON message that the XProc processor turns into a map. This is now our context item, accessible with the dot operator
            <code>.</code></para>
      </listitem>
      <listitem>
        <para>A sub-map in this map called <code>headers</code> contains the header information we&#x2019;re interested in. We extract this part into
          a variable <code>$headers</code>.</para>
      </listitem>
      <listitem>
        <para>The <tag>p:for-each</tag> loops over all keys in the <code>$headers</code> sub-map.</para>
      </listitem>
      <listitem>
        <para>A <step-ref name="p:identity"/> step is used to construct a (single element) XML document, containing the request header name and value:
            <tag>request-header name="…" value="…"/</tag></para>
      </listitem>
      <listitem>
        <para>The <tag>p:for-each</tag> loop now emits a sequence of documents, one for each request header. A <step-ref name="p:wrap-sequence"/> step
          wraps this into an <tag>http-request-headers</tag> root element to produce a well-formed XML document.</para>
      </listitem>
    </itemizedlist>

    <xproc-example href="../../examples/http-request/http-request-02.xpl" keep-namespace-prefixes-pipeline="map">
      <pipeline-header/>
    </xproc-example>

  </example>

  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

  <example title="Adding a request header" id="adding-rh">

    <xproc-example href="../../examples/http-request/http-request-03.xpl" keep-namespace-prefixes-pipeline="map">
      <pipeline-header>
        <para>The <option>headers</option> option can be used for additional request headers. In this example we add the bogus request header called
            <code>xyz</code> and set it to the value <code>123</code>. The code to view the request headers is identical to that of <example-ref
            idref="viewing-rh"/>:</para>
      </pipeline-header>
    </xproc-example>

    <para>Notice that the name of the request header is capitalized into <code>Xyz</code>. Request header names are case-insensitive, but it is custom
      to capitalize them (start with an upper-case character).</para>

  </example>

  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

  <example title="Viewing the response headers" id="viewing-response-h">

    <xproc-example href="../../examples/http-request/http-request-04.xpl" keep-namespace-prefixes-pipeline="map">
      <pipeline-header>
        <para>Inspecting the response headers can be done by using the map returned on the <port>report</port> port (see <xref linkend="http-report"
          />). The code to view the response headers is almost identical to that of <example-ref idref="viewing-rh"/>:</para>
      </pipeline-header>
    </xproc-example>

  </example>

  <!-- ======================================================================= -->

  <step-errors>
    <step-error code="XC0128"/>
    <step-error code="XC0122"/>
    <step-error code="XD0079"/>
    <step-error code="XC0131"/>
    <step-error code="XC0127"/>
    <step-error code="XC0123"/>
    <step-error code="XC0003"/>
    <step-error code="XC0030"/>
    <step-error code="XC0129"/>
    <step-error code="XC0125"/>
    <step-error code="XC0132"/>
    <step-error code="XC0078"/>
    <step-error code="XC0124"/>
    <step-error code="XC0126"/>
    <step-error code="XC0203"/>
    <step-error code="XC0133"/>
  </step-errors>

</step>

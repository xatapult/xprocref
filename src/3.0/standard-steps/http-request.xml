<?xml version="1.0" encoding="UTF-8"?>
<step name="http-request" version-idref="v30" category-idrefs="standard-steps" short-description="Interact using HTTP (or related protocols)"
  required="true" publish="false" href-specification="{$BASELINK-STANDARD-STEPS-V30}#c.http-request"
  xsi:schemaLocation="http://www.xtpxlib.nl/ns/xprocref ../../../xsd/xprocref.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns="http://www.xtpxlib.nl/ns/xprocref">

  <!-- ======================================================================= -->

  <signature>

    <input port="source" content-types="any" sequence="true" primary="true">
      <description>
        <para>Document(s) to construct a request body from.</para>
        <para>By default, source documents are used for HTTP methods that require a body (for instance <code>POST</code>) only. If the HTTP method
          does not specify a body (for instance <code>GET</code>), any documents appearing on the <port>source</port> port are ignored. You can
          control this behaviour with the <code>send-body-anyway</code> parameter (see <xref linkend="request-parameters"/>).</para>
      </description>
    </input>

    <output port="result" primary="true" content-types="any" sequence="true">
      <description>
        <para>The request result document(s). See <xref linkend="http-report"/>.</para>
      </description>
    </output>

    <output port="report" content-types="application/json" primary="false" sequence="true">
      <description>
        <para>A map containing information about the response. See <xref linkend="http-report"/>.</para>
      </description>
    </output>

    <option name="href" as="xs:anyURI" required="true">
      <description>
        <para>The URI to use for the request.</para>
      </description>
    </option>

    <option name="method" as="xs:string?" select="'GET'" required="false">
      <description>
        <para>The HTTP request method to use for the request. Its value is converted to upper-case.</para>
        <para>Any implementations must support the HTTP methods <code>GET</code> (default), <code>POST</code>, <code>PUT</code>, <code>DELETE</code>,
          and <code>HEAD</code>. Whether any other methods are supported is implementation-defined and therefore depends on the XProc processor used.
        </para>
      </description>
    </option>

    <option name="serialization" as="map(xs:QName,item()*)?" required="false">
      <description>
        <para>Before the document(s) on the <port>source</port> port are used, they are first serialized (as if written to disk). This option can
          supply a map with <link xlink:href="https://www.w3.org/TR/xslt-xquery-serialization-31/" role="newpage">serialization properties</link>,
          controlling this serialization.</para>
        <para>If a source document has a <property>serialization</property> document-property, the two sets of serialization properties are merged
          (properties in the <option>serialization</option> option have precedence).</para>
      </description>
    </option>

    <option name="headers" as="map(xs:string, xs:string)?" required="false">
      <description>
        <para>A map containing the request headers. Each map key is used as a header name and the value associated is used as the header value.</para>
        <para>There are some special rules regarding the request headers, see <xref linkend="request-header-specification"/>.</para>
        <para>Request headers can influence the construction of the request. See <xref linkend="request-header-usage"/>.</para>
      </description>
    </option>

    <option name="auth" as="map(xs:string, item()+)?" required="false">
      <description>
        <para>Information for the authentication of the request (in other words: about &#x201c;logging in&#x201d;). See <xref
            linkend="request-athentication"/></para>
      </description>
    </option>
    <option name="parameters" as="map(xs:QName, item()*)?" required="false">
      <description>
        <para>A map with parameters for fine-tuning the construction of the request and/or the handling of the server response. See <xref
            linkend="request-parameters"/>.</para>
      </description>
    </option>

    <option name="assert" as="xs:string" select="'.?status-code lt 400'" required="false">
      <description>
        <para>Any request can fail, but what exactly failure is depends on the expectations of the receiver. This option takes an XPath expression
          that can inspect the request results. If the result of this expression (executed after a response is received) is <code>false</code>,
          dynamic error <step-error-ref code="XC0126"/> is raised. See <xref linkend="assert-request-fails"/></para>
      </description>
    </option>

  </signature>

  <!-- ======================================================================= -->

  <summary>
    <para>The <step/> step allows authors to interact with resources (for instance websites) over HTTP or related protocols.</para>
  </summary>

  <!-- ======================================================================= -->

  <description>

    <para>TBD</para>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <section xml:id="request-header-specification">
      <title>Specifying request headers</title>

      <para>The main source for constructing the HTTP request headers is the <option>headers</option> option. However, if a
          <emphasis>single</emphasis> document appears on the <port>source</port> port, its document-properties may also be used for this. This does
        not happen when multiple documents appear on the <port>source</port> port, in that case all document-properties of all source documents are
        ignored. </para>

      <itemizedlist>

        <listitem>
          <para>If the single document appearing on the <port>source</port> port:</para>
          <itemizedlist>
            <listitem>
              <para>is an XML, HTML or text document</para>
            </listitem>
            <listitem>
              <para><emphasis>and</emphasis> has a <option>serialization</option> document-property</para>
            </listitem>
            <listitem>
              <para><emphasis>and</emphasis> this <option>serialization</option> document-property has an entry called <code>encoding</code></para>
            </listitem>
          </itemizedlist>
          <para>a <code>charset</code> is appended to the created <code>content-type</code> header of the HTTP request (see for instance <link
              xlink:href="https://www.w3.org/International/articles/http-charset/index" role="newpage">here</link>).</para>
        </listitem>

        <listitem>
          <para>Any document-properties of the single document appearing on the <port>source</port> port that are in the
              <code>http://www.w3.org/ns/xproc-http</code> namespace will be added as request header, using their local name (their name without
            namespace) as the request header name.</para>
          <para>For a request parameter specified both in a document-property and in the map provided to the <option>headers</option> option, the one
            in the <option>headers</option> option takes precedence. This comparison is case-<emphasis>in</emphasis>sensitive.</para>
        </listitem>

      </itemizedlist>

    </section>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <section xml:id="request-header-usage">
      <title>Usage of request headers</title>

      <para>Once the request headers are constructed (see <xref linkend="request-header-specification"/>), some of these are used for additional
        purposes:</para>

      <itemizedlist>

        <listitem>
          <para>If a <code>content-type</code> request header is present, it will be used as the content type of the document on the <port>source</port>
            port. This overrides the value of the <property>content-type</property> property of the document. TBD WHAT WHEN MULTPLE?</para>
          <para>If its value begins with <code>multipart/</code>, a multipart request is constructed.</para>
        </listitem>

        <listitem>
          <para>If a <code>transfer-encoding</code> request header is present, the request is sent using that particular encoding (for more
            information see <link xlink:href="https://www.rfc-editor.org/rfc/rfc9112#section-6.1" role="newpage">here</link>). Examples of values are
              <code>chunked</code>, <code>compress</code> or <code>gzip</code>.</para>
        </listitem>

        <listitem>
          <para>If the <option>auth</option> option is specified, an <code>authorization</code> request header is ignored. In that case, the value of
            the <code>authorization</code> request header is determined exclusively by the value of the <option>auth</option> option.</para>
        </listitem>

      </itemizedlist>

    </section>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <section xml:id="request-athentication">
      <title>Request authentication</title>
      <para>The <option>auth</option> option specifies the authentication for the request. It contains the credentials (username, password, etc.) of
        the client and specifies what authentication method is used.</para>

      <para>The <option>auth</option> option must be a map with string (<code>xs:string</code>) type keys. The following standard keys are
        defined:</para>

      <table role="nonumber">
        <title/>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>
                <para>Key</para>
              </entry>
              <entry>
                <para>Value data type</para>
              </entry>
              <entry>
                <para>Description</para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  <code>
                    <code>username</code>
                  </code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:string</code>
                </para>
              </entry>
              <entry>
                <para> The username for the request. </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>
                    <code>password</code>
                  </code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:string</code>
                </para>
              </entry>
              <entry>
                <para> The password associated with the username. </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>
                    <code>auth-method</code>
                  </code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:string</code>
                </para>
              </entry>
              <entry>
                <para>Specifies the authentication method to use. Standard values are <code>Basic</code> or <code>Digest</code> (see <link
                    xlink:href="https://www.rfc-editor.org/info/rfc2617" role="newpage">here</link> for further information). Whether other
                  authorization methods are supported and how to specify these is implementation-defined and therefore depends on the XProc processor
                  used.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>
                    <code>send-authorization</code>
                  </code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:boolean</code>
                </para>
              </entry>
              <entry>
                <para>This controls the &#x201c;authorization challenge&#x201d;:</para>
                <itemizedlist>
                  <listitem>
                    <para>If this key is absent or its value is not <code>true</code>, a first request is sent <emphasis>without</emphasis>
                      authorization information. If the server subsequently requests it, the request is resent <emphasis>with</emphasis> authorization
                      information. </para>
                  </listitem>
                  <listitem>
                    <para>If this key&#x2019;s value is <code>true</code>, the first request immediately contains the authorization
                      information.</para>
                  </listitem>
                </itemizedlist>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>If an authorization fails, the request is not retried.</para>
      <para>Any other key/value pairs for the <option>auth</option> option map are implementation-defined and therefore depend on the XProc processor
        used.</para>

    </section>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <section xml:id="request-parameters">
      <title>Request parameters</title>

      <para>The <option>parameters</option> option provides information for fine tuning the construction of the request and/or handling of the server
        response. It must be a map with string (<code>xs:string</code>) type keys. The following standard keys are defined:</para>

      <table role="nonumber">
        <title/>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>
                <para>Key</para>
              </entry>
              <entry>
                <para>Value data type</para>
              </entry>
              <entry>
                <para>Description</para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  <code>override-content-type</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:string</code>
                </para>
              </entry>
              <entry>
                <para>The XProc processor must know how to interpret the body of a server response, its data type. Normally this is done by looking at
                  the <code>content-type</code> response header. If this, for instance, is set to <code>application/xml</code>, the response body is
                  interpreted as an XML document. Of course this must succeed, if not, error <step-error-ref code="XC0030"/> is raised. </para>
                <para>If you specify an <code>override-content-type</code> parameter, its value is used instead of that in the
                    <code>content-type</code> response header.</para>
                <para>The information about the <code>content-type</code> response header that appears on the <port>report</port> port (see <xref
                    linkend="http-report"/>) is <emphasis>not</emphasis> changed and still reflects the actual value received from the server.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>http-version</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:string</code>
                </para>
              </entry>
              <entry>
                <para>Specifies the HTTP version to use for the request.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>accept-multipart</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:boolean</code>
                </para>
              </entry>
              <entry>
                <para>If this parameter is present and has the value <code>false</code>, any multipart response will result in raising error
                    <step-error-ref code="XC0125"/>. You can use this to prevent unexpected multipart responses to wreak havoc in your pipeline.
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>override-content-encoding</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:string</code>
                </para>
              </entry>
              <entry>
                <para>The XProc processor must know how the encoding of a server response (for instance: <code>utf-8</code>). Normally this is done by
                  looking at the <code>content-encoding</code> response header. If you specify an <code>override-content-encoding</code> parameter,
                  its value is used instead of that in the <code>content-encoding</code> response header.</para>
                <para>The information about the <code>content-encoding</code> response header that appears on the <port>report</port> port (see <xref
                    linkend="http-report"/>) is <emphasis>not</emphasis> changed and still reflects the actual value received from the server.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>permit-expired-ssl-certificate</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:boolean</code>
                </para>
              </entry>
              <entry>
                <para>If this parameter is present and has the value <code>true</code>, <step/> does not reject a response where the server provides
                  an expired SSL certificate.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>permit-untrusted-ssl-certificate</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:boolean</code>
                </para>
              </entry>
              <entry>
                <para>If this parameter is present and has the value <code>true</code>, <step/> does not reject a response where the server provides
                  an SSL certificate which is not trusted, for example, because the certificate authority (CA) is unknown.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>follow-redirect</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:integer</code>
                </para>
              </entry>
              <entry>
                <para>Sometimes a server responds with a <emphasis>redirect</emphasis>, meaning something like &#x201c;please repeat the request to
                  this different URI&#x201d;. The <code>follow-redirect</code> parameter tells the XProc processor what to do when a redirect is
                  received: </para>
                <itemizedlist>
                  <listitem>
                    <para>If its value is <code>0</code>, redirects are not followed.</para>
                  </listitem>
                  <listitem>
                    <para>If its value is negative, redirects are followed indefinitely.</para>
                  </listitem>
                  <listitem>
                    <para>If its value is positive, at most this number of subsequent redirects are followed.</para>
                  </listitem>
                </itemizedlist>
                <para>The default behaviour, when the <code>follow-redirect</code> parameter is not present, is implementation-defined and therefore
                  depends on the XProc processor used.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>timeout</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:integer</code>
                </para>
              </entry>
              <entry>
                <para>Specifies the number of seconds to wait for a response. If no response is received after approximately this
                  number of seconds, the request is terminated and HTTP status <code>408</code> is assumed. </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>fail-on-timeout</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:boolean</code>
                </para>
              </entry>
              <entry>
                <para>Sometimes a request results in a timeout. This can either happen by receiving a response with HTTP status <code>408</code> or
                  because the number of seconds specified in the <code>timeout</code> parameter is exceeded. If a <code>fail-on-timeout</code>
                  parameter is present and has the value <code>true</code>, this will result in raising error <step-error-ref code="XC0078"/>.</para>
                <para>This might be confusing, because XProc also has a <code>[p:]timeout</code> attribute, useable on all steps, that tells the XProc
                  processor how long a step invocation is allowed to take (also specified in seconds).What happens depends on whatever comes
                  first:</para>
                <itemizedlist>
                  <listitem>
                    <para>If the number of seconds specified in the <code>[p:]timeout</code> attribute is exceeded, error <code>XD0053</code> is
                      raised (a generic timeout error).</para>
                    <para>Be careful when you want to use this: whether a processor supports timeouts using the <code>[p:]timeout</code> attribute,
                      and if it does, how precisely and precisely how the execution time of a step is measured, is implementation-defined and
                      therefore depends on the XProc processor used.</para>
                  </listitem>
                  <listitem>
                    <para>If <code>fail-on-timeout</code> is <code>true</code> and a timeout happens, error <step-error-ref code="XC0078"/> is
                      raised.</para>
                  </listitem>
                </itemizedlist>

              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>status-only</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:boolean</code>
                </para>
              </entry>
              <entry>
                <para>If this parameter is present and its value is <code>true</code>, it indicates that the pipeline author is interested in the
                  response code only. The <port>result</port> port will not emit anything. The map on the <port>report</port> port will return an
                  empty map as value of its <code>headers</code> entry.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>suppress-cookies</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:boolean</code>
                </para>
              </entry>
              <entry>
                <para>If this parameter is present and its value is <code>true</code>, no cookies are sent with the request.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>send-body-anyway</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:boolean</code>
                </para>
              </entry>
              <entry>
                <para>By default, whether a body is sent with the request depends on the HTTP method used (the value of the <option>method</option>
                  option). For instance, the <code>GET</code> method does not specify a body. When the <code>GET</code> method is used, by default any
                  document(s) on the <port>source</port> port are ignored.</para>
                <para>When the <code>send-body-anyway</code> parameter is present and its value is <code>true</code>, a request body will always be
                  constructed, even if the HTTP method used does not specify this.</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Any other key/value pairs for the <option>parameters</option> option map are implementation-defined and therefore depend on the XProc
        processor used.</para>

    </section>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <section xml:id="http-report">
      <title>The response result and report</title>
      <para>TBD</para>
    </section>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <section xml:id="assert-request-fails">
      <title>Asserting the request status</title>
      <para>TBD</para>
    </section>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <section>
      <title>ORIGINAL</title>
      <para>The <tag>p:http-request</tag> step performs the HTTP request specified by the <option>method</option> option against the URI specified in
        the <option>href</option> option. In simple cases, for example, a GET request on an unauthenticated URI, nothing else is necessary to form a
        complete request.</para>
      <para>If the method, for example, POST, supports a body, the request body is constructed using the document(s) appearing on the
          <port>source</port> port. For the convenience of pipeline authors, documents may appear on the <port>source</port> port even when the
        request method (such as GET or HEAD) does not define the semantics of a payload. If the semantics are undefined, the documents are ignored
        when constructing the request unless the <option>parameters</option> option specifies “<literal>send-body-anyway</literal>” as
          <code>true()</code>.</para>
      <para>The headers for the request come from the <option>headers</option> option (see below). If exactly one document appears on the
          <port>source</port> port, its document properties also contribute to the overall request headers.</para>
      <para>The response from the HTTP request appears on the <port>result</port> and <port>report</port> ports. Any documents contained in the
        response body will appear on the <port>result</port> port. Each document in the response will be parsed according to its content-type (but see
          “<literal>override-content-type</literal>” in the <option>parameters</option> option). Details about the outcome of the request will appear
        as a map on the <port>report</port> port. The map will always contain: </para>
      <variablelist>
        <varlistentry>
          <term>
            <literal>status-code</literal> (an <code>xs:integer</code>)</term>
          <listitem>
            <para>This is the HTTP status code returned for the request.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>base-uri</literal> (an <code>xs:anyURI</code>)</term>
          <listitem>
            <para>This is the URI of the last request made and is always available in the report even when the request does not return any documents.
              In the case of HTTP redirection, the base URI returned may be different from the original request URI. </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>headers</literal> (a <code>map(xs:string, xs:string)</code>)</term>
          <listitem>
            <para>These are the HTTP headers returned for the request. The map may be empty. Header names are converted to lowercase.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>The <tag>p:http-request</tag> step has the following options:</para>
      <variablelist>
        <varlistentry>
          <term>
            <option>href</option>
          </term>
          <listitem>
            <para>The <option>href</option> option specifies the request’s IRI. Relative values are resolved against the base URI of the element on
              which the option is specified (the relevant <tag>p:with-option</tag> or the step element in the case of a syntactic shortcut
              value).</para>
            <para>Fragment identifiers are removed before making the request. Query parameters are passed through unchanged. <emphasis role="bold"
                >[ERROR <step-error-ref code="XC0128"/>]</emphasis> It is the pipeline author’s responsibility to escape problematic UTF-8 characters
              in the <option>href</option> value, for example with <function>escape-html-uri()</function>. </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <option>method</option>
          </term>
          <listitem>
            <para>The <option>method</option> specifies the HTTP request method. The value is implicitly turned into an uppercase string if necessary.
              It is implementation defined which HTTP methods are supported. An implementation should implement at least the methods
                <literal>GET</literal>, <literal>POST</literal>, <literal>PUT</literal>, <literal>DELETE</literal>, and <literal>HEAD</literal> (for
              HTTP and HTTPS). <emphasis role="bold">[ERROR <step-error-ref code="XC0122"/>]</emphasis>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <option>serialization</option>
          </term>
          <listitem>
            <para>The <option>serialization</option> option is used to control the serialization of documents for the request body. If a document has
              a “<literal>serialization</literal>” document property, the effective value of the serialization options is the union of the two maps,
              where the entries in the “<literal>serialization</literal>” document property take precedence.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <option>headers</option>
          </term>
          <listitem>
            <para>The key/value pairs in the <option>headers</option> map are used to construct the request headers. Each map key is used as a header
              name and the value associated with that key in the map is used as the header value.</para>
            <para>If a single document appears on the <port>source</port> port, then document properties on that document may be added as additional
              headers. For XML, HTML, and text documents with a <literal>serialization</literal> document property having an
                <literal>encoding</literal> key, a <literal>charset</literal> is appended to the created <literal>content-type</literal> header of the
              HTTP request. Properties in the <code>http://www.w3.org/ns/xproc-http</code> namespace will be added to the headers, using the
              local-name of the property QName as the header name. These properties are only copied if they are not specified in the
                <option>header</option> map. In other words, if the same header name appears in both places, the value from the map is used and the
              value from the document properties is ignored. (Header names are case-insensitive, so a case-insensitive comparison must be performed.)
              If multiple documents appear on the <port>source</port> port, none of their properties are used in the request headers.</para>
            <para>The behavior of the <tag>p:http-request</tag> depends on the headers specified. In particular:</para>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>content-type</literal>
                </term>
                <listitem>
                  <para>If a <literal>content-type</literal> header is provided, it will be used. For a single document request, this overrides the
                    content type value of the document. If the content type specified begins with “<literal>multipart/</literal>”, a multipart request
                    will be sent to the server.</para>
                  <para>
                    <emphasis role="bold">[ERROR <step-error-ref code="XD0079"/>]</emphasis>
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>transfer-encoding</literal>
                </term>
                <listitem>
                  <para>If a <literal>transfer-encoding</literal> header is provided, the request must be sent with that encoding. <emphasis
                      role="bold">[ERROR <step-error-ref code="XC0131"/>]</emphasis>
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>authorization</literal>
                </term>
                <listitem>
                  <para>The <literal>authorization</literal> header is used to authenticate a request. If the <option>auth</option>
                    <emphasis>option</emphasis> is specified, any key or property that would have contributed a header named
                      “<literal>authorization</literal>” (irrespective of case) is ignored. The authorization header is determined exclusively by the
                      <option>auth</option> option when it is present.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <para>HTTP headers are case-insensitive but keys in maps are not; be careful when specifying the request headers. <emphasis role="bold"
                >[ERROR <step-error-ref code="XC0127"/>]</emphasis> (That is, when <code>fn:uppercase($key1) = fn:uppercase($key2)</code>.) </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <option>auth</option>
          </term>
          <listitem>
            <para>Many web services are only available to authenticated users, that is, to users who have “logged in”. The <option>auth</option>
              option allows the pipeline author to specify information that may be required to generate an “<literal>Authorization</literal>” header.
              The standard values support HTTP “Basic” and “Digest” authentication, but other authentication methods are allowed.</para>
            <para>The following standard keys are defined:</para>
            <variablelist>
              <varlistentry>
                <term>
                  <literal>username</literal> (<code>xs:string</code>)</term>
                <listitem>
                  <para>The username.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>password</literal> (<code>xs:string</code>)</term>
                <listitem>
                  <para>The password associated with the username.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>auth-method</literal> (<code>xs:string</code>)</term>
                <listitem>
                  <para>The authentication method. Appropriate values for the “<literal>auth-method</literal>” key are “<literal>Basic</literal>” or
                      “<literal>Digest</literal>” but other values are allowed. If the authentication method is “<literal>Basic</literal>” or
                      “<literal>Digest</literal>”, authentication is handled as per <link xlink:href="https://www.rfc-editor.org/info/rfc2617"
                      role="newpage" xmlns:xlink="http://www.w3.org/1999/xlink">RFC 2617</link> . The interpretation of values associated with the
                      “<literal>auth-method</literal>” key other than “<literal>Basic</literal>” or “<literal>Digest</literal>” is implementation
                    defined.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                  <literal>send-authorization</literal> (<code>xs:boolean</code>)</term>
                <listitem>
                  <para>The “<literal>send-authorization</literal>” key can be used to attempt to allow the request to avoid an authentication
                    challenge. If the “<literal>send-authorization</literal>” key is “<literal>true()</literal>”, and the authentication method
                    specified by the value associated with the “<literal>auth-method</literal>” key supports generation of an
                      “<literal>Authorization</literal>” header without a challenge, then the header is generated and sent on the first request. If
                    the “<literal>send-authorization</literal>” key is absent or does not have the value “<literal>true</literal>”, the first request
                    is sent without an “<literal>Authorization</literal>” header.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <para>Other key value pairs in map “<literal>auth</literal>” are implementation defined. <emphasis role="bold">[ERROR <step-error-ref
                  code="XC0123"/>]</emphasis>
            </para>
            <para>If the initial response to the request is an authentication challenge, the values provided in the <literal>auth</literal> map and
              any relevant data from the challenge are used to generate an “<literal>Authorization</literal>” header and the request is sent again. If
              that authorization fails, the request is not retried.</para>
            <para>
              <emphasis role="bold">[ERROR <step-error-ref code="XC0003"/>]</emphasis> All implementations must support “Basic” and “Digest”
              authentication per <link xlink:href="https://www.rfc-editor.org/info/rfc2617" role="newpage" xmlns:xlink="http://www.w3.org/1999/xlink"
                >RFC 2617</link> .</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>parameters</term>
          <listitem>
            <para>The <option>parameter</option> option can be used to provide values for fine tuning the construction of the request and/or handling
              of the server response. A number of parameters are defined in this specification. It is implementation defined which other key/value
              pairs in the <option>parameters</option> option are supported.</para>
            <variablelist>
              <varlistentry>
                <term>override-content-type (<code>xs:string</code>)</term>
                <listitem>
                  <para>Ordinarily, the value of the <literal>content-type</literal> header provided in the server response controls the
                    interpretation of any body in the response. If the “<literal>override-content-type</literal>” parameter is provided, then its
                    value is used to interpret the body. The content-type header that appears on the <port>report</port> port is not changed.
                      <emphasis role="bold">[ERROR <step-error-ref code="XD0079"/>]</emphasis>
                    <emphasis role="bold">[ERROR <step-error-ref code="XC0030"/>]</emphasis>
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>http-version (<code>xs:string</code>)</term>
                <listitem>
                  <para>The <literal>http-version</literal> parameter indicates which version of HTTP must be used for the request. <emphasis
                      role="bold">[ERROR <step-error-ref code="XC0129"/>]</emphasis>
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>accept-multipart (<code>xs:boolean</code>)</term>
                <listitem>
                  <para>If the <literal>accept-multipart</literal> parameter is present and explicitly has the value <code>false()</code>, a dynamic
                    error will be raised, if a multipart response is received from the server. This feature is a convenience for pipeline authors as
                    it will raise an error when the multipart request is received, rather than having the presence of a sequence raise an error
                    further along in the pipeline, or simply producing anomalous results. <emphasis role="bold">[ERROR <step-error-ref code="XC0125"
                      />]</emphasis>
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>override-content-encoding (<code>xs:string</code>)</term>
                <listitem>
                  <para>If the “<literal>override-content-encoding</literal>” parameter is present, the response will be treated as if the response
                    contained a “<literal>content-encoding</literal>” header with the specified value. The content-encoding header that appears on the
                      <port>report</port> port is not changed. <emphasis role="bold">[ERROR <step-error-ref code="XC0132"/>]</emphasis>
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>permit-expired-ssl-certificate (<code>xs:boolean</code>)</term>
                <listitem>
                  <para>If “<literal>permit-expired-ssl-certificate</literal>” is true, then the processor should not reject responses where the
                    server provides an expired SSL certificate.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>permit-untrusted-ssl-certificate (<code>xs:boolean</code>)</term>
                <listitem>
                  <para>If “<literal>permit-untrusted-ssl-certificate</literal>” is true, then the processor should not reject response where the
                    server provides an SSL certificate which is not trusted, for example, because the certificate authority (CA) is unknown.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>follow-redirect (<code>xs:integer</code>)</term>
                <listitem>
                  <para>The “<literal>follow-redirect</literal>” parameter allows the pipeline author to specify the step’s behaviour in the case of a
                    redirect response. A value of <literal>0</literal> indicates that redirects are not to be followed, <literal>-1</literal>
                    indicates that redirects are to be followed indefinitely, and a specific number indicates the maximum number of redirects to
                    follow. The default behaviour in case of a redirect response is implementation defined. </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>timeout (<code>xs:integer</code>)</term>
                <listitem>
                  <para>If a “<literal>timeout</literal>” is specified, it must be a non-negative integer. It controls the time the XProc processor
                    waits for the request to be answered. If a value is given, it is taken as the number of seconds to wait for the response to be
                    delivered. If no response is received after that time, the request is terminated and a status-code <literal>408</literal> is
                    assumed.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>fail-on-timeout (<code>xs:boolean</code>)</term>
                <listitem>
                  <para>If “<literal>fail-on-timeout</literal>” is true, a dynamic error is raised if a <literal>408</literal> response is received
                    (either as a consequence of setting a value for the “<literal>timeout</literal>” parameter or as status code returned by a
                    server). <emphasis role="bold">[ERROR <step-error-ref code="XC0078"/>]</emphasis> If “<literal>fail-on-timeout</literal>” is true,
                    it prevents any dynamic error with code <literal>C0126</literal> resulting from the <option>assert</option> option to be raised
                    for request's timeout.</para>
                  <note>
                    <title>Note</title>
                    <para>Please note that the “<literal>fail-on-timeout</literal>” parameter is different from the “<literal>timeout</literal>”
                      option on the <tag>p:http-request</tag> step (see <xspecref spec="xproc" xref="timeout"/>). If the <emphasis>step</emphasis>
                      does not finish in the specified time, <code>D0053</code> is raised. If the <emphasis>request</emphasis> does not finish in
                      time, and <literal>fail-on-timeout</literal> is true, <code>C0078</code> is raised. The actual times after which a timeout is
                      detected may also differ slightly. </para>
                  </note>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>status-only (<code>xs:boolean</code>)</term>
                <listitem>
                  <para>If the “<literal>status-only</literal>” parameter is true, this indicates that the pipeline author is only interested in the
                    response code. An empty sequence is always returned on the <port>result</port> port in this case. The implementation may save
                    resources by ignoring the response body. The map on the <port>report</port> will contain the status code and an empty map for
                      “<literal>headers</literal>”.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>suppress-cookies (<code>xs:boolean</code>)</term>
                <listitem>
                  <para>If the “<literal>suppress-cookies</literal>” parameter is true, the implementation must not send any cookies with the
                    request.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>send-body-anyway (<code>xs:boolean</code>)</term>
                <listitem>
                  <para>If the “<literal>send-body-anyway</literal>” parameter is true, and one or more documents appear on the <port>source</port>
                    port, a request body is constructed from the documents and sent with the request, even if the semantics of sending a body are not
                    specified for the HTTP method in use. </para>
                </listitem>
              </varlistentry>
            </variablelist>
            <para>
              <emphasis role="bold">[ERROR <step-error-ref code="XC0124"/>]</emphasis>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>assert (<code>xs:string</code>)</term>
          <listitem>
            <para>The <option>assert</option> option can be used by pipeline authors to raise a dynamic error if the response does not fulfill the
              expectations of the receiver. The option's value (if present) is interpreted as an XPath expression which will be executed using the map
              that appears on the <port>report</port> port as its context item. If the effective boolean value of the expression is
                <code>false()</code>, a dynamic error is raised. <emphasis role="bold">[ERROR <step-error-ref code="XC0126"/>]</emphasis>
              Implementations should provide an XML representation of the map used as the context item with the error document to enable pipelines to
              access the error's cause.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <sect2 xml:id="c.http-multipart-request">
        <title>Construction of a multipart request</title>
        <para>If more than one document appears on the <port>source</port> port, or if the specified “<literal>content-type</literal>” header begins
            “<literal>multipart/</literal>”, a multipart request will be constructed, per <link xlink:href="https://www.rfc-editor.org/info/rfc1521"
            role="newpage" xmlns:xlink="http://www.w3.org/1999/xlink">RFC 1521</link> . The content type of the request is derived from the
            “<literal>content-type</literal>” header:</para>
        <itemizedlist>
          <listitem>
            <para>If the “<literal>content-type</literal>” header specifies a multipart content type, that value will be used as the content type. If
              the header includes a <literal>boundary</literal> parameter, that value will be used as the boundary. <emphasis role="bold">[ERROR
                  <step-error-ref code="XC0203"/>]</emphasis>
            </para>
          </listitem>
          <listitem>
            <para>If the “<literal>content-type</literal>” header is not specified, “<literal>multipart/mixed</literal>” will be used.</para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="bold">[ERROR <step-error-ref code="XC0133"/>]</emphasis>
            </para>
          </listitem>
        </itemizedlist>
        <para>A multipart request must have a boundary marker, if one isn’t specified in the content type, the implementation must construct one. It
          is implementation-defined how a multipart boundary is constructed. Implementations <emphasis>are not</emphasis> required to guarantee that
          the constructed value does not appear accidentally in the multipart data. If it does, the request will be malformed; pipeline authors must
          provide a boundary if they wish to assure that this cannot happen.</para>
        <para>Each document in the sequence is serialized. If the document has a “<literal>serialization</literal>” document property, its values are
          used to determine how serialization is performed.</para>
        <para>All of the document properties in the <code>http://www.w3.org/ns/xproc-http</code> namespace will be added as headers for the part,
          using the local-name of the property QName as the header name. In particular, this is how the “<literal>id</literal>”,
            “<literal>description</literal>”, “<literal>disposition</literal>” and other multipart headers can be provided.</para>
      </sect2>
      <sect2 xml:id="c.http-multipart-response">
        <title>Managing a multipart response</title>
        <para>When a multipart response is received, each part is interpreted according to it’s content type and a pipeline document is constructed.
          Any additional headers associated with the part are added to the document properties of the constructed document.</para>
        <para>The multipart response is the resulting sequence of documents.</para>
      </sect2>
      <bridgehead>Document properties</bridgehead>
      <para feature="http-request-preserves-none">No document properties are preserved.</para>
    </section>

  </description>

  <!-- ======================================================================= -->

  <detail>
    <para>A relative value for the <option>href</option> option is resolved against the base URI of the element on which this option is specified. In
      most cases this will be the static base URI of your pipeline (the path where the XProc source containing the <step/> is stored). This is very
      probably not what you want. </para>
  </detail>

  <detail>
    <para>HTTP request header names are case-insensitive, but keys in maps are not. This means that you could specify the same request header multiple
      times in the <option>headers</option> option. For instance as <code>Content-Type</code> and <code>content-type</code>. If that happens, error
        <step-error-ref code="XC0127"/> is raised.</para>
  </detail>

  <!-- ======================================================================= -->


  <step-errors>
    <step-error code="XC0128"/>
    <step-error code="XC0122"/>
    <step-error code="XD0079"/>
    <step-error code="XC0131"/>
    <step-error code="XC0127"/>
    <step-error code="XC0123"/>
    <step-error code="XC0003"/>
    <step-error code="XC0030"/>
    <step-error code="XC0129"/>
    <step-error code="XC0125"/>
    <step-error code="XC0132"/>
    <step-error code="XC0078"/>
    <step-error code="XC0124"/>
    <step-error code="XC0126"/>
    <step-error code="XC0203"/>
    <step-error code="XC0133"/>
  </step-errors>

</step>

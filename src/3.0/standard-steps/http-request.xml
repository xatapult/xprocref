<?xml version="1.0" encoding="UTF-8"?>
<step name="http-request" version-idref="v30" category-idrefs="standard-steps" short-description="Interact using HTTP (or related protocols)"
  required="true" publish="false" href-specification="{$BASELINK-STANDARD-STEPS-V30}#c.http-request"
  xsi:schemaLocation="http://www.xtpxlib.nl/ns/xprocref ../../../xsd/xprocref.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns="http://www.xtpxlib.nl/ns/xprocref">

  <!-- ======================================================================= -->

  <signature>

    <input port="source" content-types="any" sequence="true" primary="true">
      <description>
        <para>Document(s) to construct a request body from.</para>
        <para>By default, source documents are used for HTTP methods that require a body (for instance <code>POST</code>) only. If the HTTP method
          does not specify a body (for instance <code>GET</code>), any documents appearing on the <port>source</port> port are ignored. You can
          control this behaviour with the <code>send-body-anyway</code> parameter (see <xref linkend="request-parameters"/>).</para>
      </description>
    </input>

    <output port="result" primary="true" content-types="any" sequence="true">
      <description>
        <para>The request result document(s). See <xref linkend="http-report"/>.</para>
      </description>
    </output>

    <output port="report" content-types="application/json" primary="false" sequence="true">
      <description>
        <para>A map containing information about the response. See <xref linkend="http-report"/>.</para>
      </description>
    </output>

    <option name="href" as="xs:anyURI" required="true">
      <description>
        <para>The URI to use for the request.</para>
      </description>
    </option>

    <option name="method" as="xs:string?" select="'GET'" required="false">
      <description>
        <para>The HTTP request method to use for the request. Its value is converted to upper-case.</para>
        <para>Any implementations must support the HTTP methods <code>GET</code> (default), <code>POST</code>, <code>PUT</code>, <code>DELETE</code>,
          and <code>HEAD</code>. Whether any other methods are supported is implementation-defined and therefore depends on the XProc processor used.
        </para>
      </description>
    </option>

    <option name="serialization" as="map(xs:QName,item()*)?" required="false">
      <description>
        <para>Before the document(s) on the <port>source</port> port are used, they are first serialized (as if written to disk). This option can
          supply a map with <link xlink:href="https://www.w3.org/TR/xslt-xquery-serialization-31/" role="newpage">serialization properties</link>,
          controlling this serialization.</para>
        <para>If a source document has a <property>serialization</property> document-property, the two sets of serialization properties are merged
          (properties in the <option>serialization</option> option have precedence).</para>
      </description>
    </option>

    <option name="headers" as="map(xs:string, xs:string)?" required="false">
      <description>
        <para>A map containing the request headers. Each map key is used as a header name and the value associated is used as the header value.</para>
        <para>There are some special rules regarding the request headers, see <xref linkend="request-header-specification"/>.</para>
        <para>Request headers can influence the construction of the request. See <xref linkend="request-header-usage"/>.</para>
      </description>
    </option>

    <option name="auth" as="map(xs:string, item()+)?" required="false">
      <description>
        <para>Information for the authentication of the request (in other words: about &#x201c;logging in&#x201d;). See <xref
            linkend="request-athentication"/></para>
      </description>
    </option>
    <option name="parameters" as="map(xs:QName, item()*)?" required="false">
      <description>
        <para>A map with parameters for fine-tuning the construction of the request and/or the handling of the server response. See <xref
            linkend="request-parameters"/>.</para>
      </description>
    </option>

    <option name="assert" as="xs:string" select="'.?status-code lt 400'" required="false">
      <description>
        <para>Any request can fail, but what exactly failure is depends on the expectations of the receiver. This option takes an XPath expression
          that can inspect the request results. If the result of this expression (executed after a response is received) is <code>false</code>,
          dynamic error <step-error-ref code="XC0126"/> is raised. See <xref linkend="assert-request-fails"/></para>
      </description>
    </option>

  </signature>

  <!-- ======================================================================= -->

  <summary>
    <para>The <step/> step allows authors to interact with resources (for instance websites) over HTTP or related protocols.</para>
  </summary>

  <!-- ======================================================================= -->

  <description>

    <para>TBD</para>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <section xml:id="request-header-specification">
      <title>Specifying request headers</title>

      <para>The main source for constructing the HTTP request headers is the <option>headers</option> option. However, if a
          <emphasis>single</emphasis> document appears on the <port>source</port> port, its document-properties may also be used for this. This does
        not happen when multiple documents appear on the <port>source</port> port, in that case all document-properties of all source documents are
        ignored. </para>

      <itemizedlist>

        <listitem>
          <para>If the (single) document appearing on the <port>source</port> port:</para>
          <itemizedlist>
            <listitem>
              <para>is an XML, HTML or text document,</para>
            </listitem>
            <listitem>
              <para><emphasis>and</emphasis> has a <option>serialization</option> document-property,</para>
            </listitem>
            <listitem>
              <para><emphasis>and</emphasis> this <option>serialization</option> document-property has an entry called <code>encoding</code>,</para>
            </listitem>
          </itemizedlist>
          <para>a <code>charset</code> is appended to the created <code>content-type</code> header of the HTTP request (for more information about
            this <code>charset</code> parameter, see for instance <link xlink:href="https://www.w3.org/International/articles/http-charset/index"
              role="newpage">here</link>).</para>
        </listitem>

        <listitem>
          <para>Any document-properties of the (single) document appearing on the <port>source</port> port that are in the
              <code>http://www.w3.org/ns/xproc-http</code> namespace will be added as request header, using their local name (their name without
            namespace) as the request header name.</para>
          <para>For a request parameter specified both in a document-property and in the map provided to the <option>headers</option> option, the one
            in the <option>headers</option> option takes precedence. This comparison is case-<emphasis>in</emphasis>sensitive.</para>
        </listitem>

      </itemizedlist>

    </section>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <section xml:id="request-header-usage">
      <title>Usage of request headers</title>

      <para>Once the request headers are constructed (see <xref linkend="request-header-specification"/>), some of these are used for additional
        purposes:</para>

      <itemizedlist>

        <listitem>
          <para>If:</para>
          <itemizedlist>
            <listitem>
              <para>a single document appears on the <port>source</port> port,</para>
            </listitem>
            <listitem>
              <para><emphasis>and</emphasis> a <code>content-type</code> request header is present,</para>
            </listitem>
            <listitem>
              <para><emphasis>and</emphasis> the <code>content-type</code> does <emphasis>not</emphasis> start with <code>multipart/</code>,</para>
            </listitem>
          </itemizedlist>
          <para>the value of the <code>content-type</code> request header overrides the value of the <property>content-type</property>
            document-property.</para>
        </listitem>

        <listitem>
          <para>If the value of the <code>content-type</code> request header starts with <code>multipart/</code>, a multipart request is constructed.
            (regardless of the number of documents appearing on the <port>source</port> port). See <xref linkend="multipart"/>.</para>
        </listitem>

        <listitem>
          <para>If a <code>transfer-encoding</code> request header is present, the request is sent using that particular encoding (for more
            information about transfer encodings see <link xlink:href="https://www.rfc-editor.org/rfc/rfc9112#section-6.1" role="newpage"
            >here</link>). Examples of values are <code>chunked</code>, <code>compress</code> or <code>gzip</code>.</para>
        </listitem>

        <listitem>
          <para>If the <option>auth</option> option is specified, an <code>authorization</code> request header is ignored. Instead, the value of the
              <code>authorization</code> request header is determined exclusively by the value of the <option>auth</option> option.</para>
        </listitem>

      </itemizedlist>

    </section>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <section xml:id="request-athentication">
      <title>Request authentication</title>
      <para>The <option>auth</option> option contains the credentials (username, password, etc.) of the client and specifies what authentication
        method is used. It must be a map with string (<code>xs:string</code>) type keys. The following standard keys are defined:</para>

      <table role="nonumber">
        <title/>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>
                <para>Key</para>
              </entry>
              <entry>
                <para>Value data type</para>
              </entry>
              <entry>
                <para>Description</para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  <code>
                    <code>username</code>
                  </code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:string</code>
                </para>
              </entry>
              <entry>
                <para> The username for the request. </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>
                    <code>password</code>
                  </code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:string</code>
                </para>
              </entry>
              <entry>
                <para> The password associated with the username. </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>
                    <code>auth-method</code>
                  </code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:string</code>
                </para>
              </entry>
              <entry>
                <para>Specifies the authentication method to use. Standard values are <code>Basic</code> or <code>Digest</code> (see <link
                    xlink:href="https://www.rfc-editor.org/info/rfc2617" role="newpage">here</link> for further information). Whether other
                  authorization methods are supported and how to specify these is implementation-defined and therefore depends on the XProc processor
                  used.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>
                    <code>send-authorization</code>
                  </code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:boolean</code>
                </para>
              </entry>
              <entry>
                <para>This controls the &#x201c;authorization challenge&#x201d;:</para>
                <itemizedlist>
                  <listitem>
                    <para>If this key is absent or its value is not <code>true</code>, a first request is sent <emphasis>without</emphasis>
                      authorization information. If the server subsequently requests it, the request is resent <emphasis>with</emphasis> authorization
                      information. </para>
                  </listitem>
                  <listitem>
                    <para>If this key&#x2019;s value is <code>true</code>, the first request immediately contains the authorization
                      information.</para>
                  </listitem>
                </itemizedlist>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>If an authorization fails, the request is not retried.</para>
      <para>Any other key/value pairs for the <option>auth</option> option map are implementation-defined and therefore depend on the XProc processor
        used.</para>

    </section>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <section xml:id="request-parameters">
      <title>Parameters</title>

      <para>The <option>parameters</option> option provides information for fine tuning the construction of the request and/or handling the response.
        It must be a map with string (<code>xs:string</code>) type keys. The following standard keys are defined:</para>

      <table role="nonumber">
        <title/>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>
                <para>Key</para>
              </entry>
              <entry>
                <para>Value data type</para>
              </entry>
              <entry>
                <para>Description</para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  <code>override-content-type</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:string</code>
                </para>
              </entry>
              <entry>
                <para>The XProc processor must know how to interpret the body of a server response, its data type. Normally this is done by looking at
                  the <code>content-type</code> response header. If this, for instance, is set to <code>application/xml</code>, the response body is
                  interpreted as an XML document. Of course this must succeed, if not, error <step-error-ref code="XC0030"/> is raised. </para>
                <para>If you specify an <code>override-content-type</code> parameter, its value is used instead of that in the
                    <code>content-type</code> response header.</para>
                <para>The information about the <code>content-type</code> response header that appears on the <port>report</port> port (see <xref
                    linkend="http-report"/>) is <emphasis>not</emphasis> changed and still reflects the actual value received from the server.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>http-version</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:string</code>
                </para>
              </entry>
              <entry>
                <para>Specifies the HTTP version to use for the request. Its default value is implementation-defined and therefore depends on the
                  XProc processor used. Most probably it will be <code>1.1</code>.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>accept-multipart</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:boolean</code>
                </para>
              </entry>
              <entry>
                <para>If this parameter is present and has the value <code>false</code>, any multipart response will result in raising error
                    <step-error-ref code="XC0125"/>. You can use this to prevent unexpected multipart responses wreak havoc in your pipeline. </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>override-content-encoding</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:string</code>
                </para>
              </entry>
              <entry>
                <para>The XProc processor must know how the encoding of a server response (for instance: <code>utf-8</code>). Normally this is done by
                  looking at the <code>content-encoding</code> response header. If you specify an <code>override-content-encoding</code> parameter,
                  its value is used instead of that in the <code>content-encoding</code> response header.</para>
                <para>The information about the <code>content-encoding</code> response header that appears on the <port>report</port> port (see <xref
                    linkend="http-report"/>) is <emphasis>not</emphasis> changed and still reflects the actual value received from the server.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>permit-expired-ssl-certificate</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:boolean</code>
                </para>
              </entry>
              <entry>
                <para>If this parameter is present and has the value <code>true</code>, <step/> does <emphasis>not</emphasis> reject a response where
                  the server provides an expired SSL certificate.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>permit-untrusted-ssl-certificate</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:boolean</code>
                </para>
              </entry>
              <entry>
                <para>If this parameter is present and has the value <code>true</code>, <step/> does <emphasis>not</emphasis> reject a response where
                  the server provides an SSL certificate which is not trusted, for example, because the certificate authority (CA) is unknown.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>follow-redirect</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:integer</code>
                </para>
              </entry>
              <entry>
                <para>Sometimes a server responds with a <emphasis>redirect</emphasis>, meaning something like &#x201c;please repeat the request to
                  this different URI&#x201d;. The <code>follow-redirect</code> parameter tells the XProc processor what to do when a redirect is
                  received: </para>
                <itemizedlist>
                  <listitem>
                    <para>If its value is <code>0</code>, redirects are not followed.</para>
                  </listitem>
                  <listitem>
                    <para>If its value is <code>-1</code>, redirects are followed indefinitely.</para>
                  </listitem>
                  <listitem>
                    <para>If its value is <emphasis>positive</emphasis>, at most this number of subsequent redirects are followed.</para>
                  </listitem>
                </itemizedlist>
                <para>The default behaviour, when the <code>follow-redirect</code> parameter is not present, is implementation-defined and therefore
                  depends on the XProc processor used.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>timeout</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:integer</code>
                </para>
              </entry>
              <entry>
                <para>Specifies the number of seconds to wait for a response. If no response is received after approximately this number of seconds,
                  the request is terminated and HTTP status <code>408</code> is assumed. </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>fail-on-timeout</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:boolean</code>
                </para>
              </entry>
              <entry>
                <para>Sometimes a request results in a timeout. This can either happen by receiving a response with HTTP status <code>408</code> or
                  because the number of seconds specified in the <code>timeout</code> parameter is exceeded. If a <code>fail-on-timeout</code>
                  parameter is present and has the value <code>true</code>, this will result in raising error <step-error-ref code="XC0078"/>.</para>
                <para>This might be confusing, because XProc also has a <code>[p:]timeout</code> attribute, useable on all steps, that tells the XProc
                  processor how long a step invocation is allowed to take (also specified in seconds). What happens depends on whatever comes
                  first:</para>
                <itemizedlist>
                  <listitem>
                    <para>If the number of seconds specified in the <code>[p:]timeout</code> attribute is exceeded, error <code>XD0053</code> is
                      raised (a generic timeout error).</para>
                    <para>Be careful when you want to use this: whether a processor supports timeouts using the <code>[p:]timeout</code> attribute,
                      and if it does, how precisely and precisely how the execution time of a step is measured, is implementation-defined and
                      therefore depends on the XProc processor used.</para>
                  </listitem>
                  <listitem>
                    <para>If <code>fail-on-timeout</code> is <code>true</code> and a timeout happens, error <step-error-ref code="XC0078"/> is
                      raised.</para>
                  </listitem>
                </itemizedlist>

              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>status-only</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:boolean</code>
                </para>
              </entry>
              <entry>
                <para>If this parameter is present and its value is <code>true</code>, it indicates that the pipeline author is interested in the
                  response code only. The <port>result</port> port will not emit anything. The map on the <port>report</port> port will return an
                  empty map as value of its <code>headers</code> entry.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>suppress-cookies</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:boolean</code>
                </para>
              </entry>
              <entry>
                <para>If this parameter is present and its value is <code>true</code>, no cookies are sent with the request.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>send-body-anyway</code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:boolean</code>
                </para>
              </entry>
              <entry>
                <para>By default, whether a body is sent with the request depends on the HTTP method used (the value of the <option>method</option>
                  option). For instance, the <code>GET</code> method does not specify a body. When the <code>GET</code> method is used, by default any
                  document(s) on the <port>source</port> port are ignored.</para>
                <para>When the <code>send-body-anyway</code> parameter is present and its value is <code>true</code>, a request body will always be
                  constructed, even if the HTTP method used does not specify this.</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Any other key/value pairs for the <option>parameters</option> option map are implementation-defined and therefore depend on the XProc
        processor used.</para>

    </section>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <section xml:id="http-report">
      <title>The response result and report</title>

      <para>When an answer is received from the server, document(s) in the response body will appear as separate document(s) on the
          <port>result</port> port. Each document will be parsed according to its content-type. You can override this behaviour using the
          <code>override-content-type</code> parameter (see <xref linkend="request-parameters"/>).</para>
      
      <para>In case of a multipart response, each part will become a separate document appearing on the <port>result</port> port. Any
         response headers associated with a specific part are added to the document-properties of the resulting
        document.</para>

      <para>The <port>report</port> port always returns a map with the following keys/entries:</para>

      <table role="nonumber">
        <title/>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>
                <para>Key</para>
              </entry>
              <entry>
                <para>Value data type</para>
              </entry>
              <entry>
                <para>Description</para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  <code>
                    <code>status-code</code>
                  </code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:integer</code>
                </para>
              </entry>
              <entry>
                <para>The HTTP status code for the request, for instance <code>200</code> (success) or <code>404</code> (failure).</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>
                    <code>base-uri</code>
                  </code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>xs:anyURI</code>
                </para>
              </entry>
              <entry>
                <para>The URI of the request.</para>
                <para>In case of HTTP redirection, this value may be different from the original request URI.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  <code>
                    <code>headers</code>
                  </code>
                </para>
              </entry>
              <entry>
                <para>
                  <code>map(xs:string, xs:string)</code>
                </para>
              </entry>
              <entry>
                <para>The HTTP headers returned for the request. Header names are in lower-case. The map may be empty.</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      

    </section>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <section xml:id="assert-request-fails">
      <title>Asserting the request status</title>
      <para>Any request can fail, but what exactly failure is depends on the expectations of the receiver. The <code>assert</code> option of <step/>
        takes an XPath expression that  inspects the request results:</para>
      <itemizedlist>
        <listitem>
          <para>It must contain a valid (boolean) XPath expression.</para>
        </listitem>
        <listitem>
          <para>This expression will be executed when a response is received.</para>
        </listitem>
        <listitem>
          <para>The context item when executing the expression is the map that also appears on the <port>report</port> port (see <xref
              linkend="http-report"/>).</para>
        </listitem>
        <listitem>
          <para>If the expression evaluates to <code>false</code>, error <step-error-ref code="XC0126"/> is raised.</para>
        </listitem>
        <listitem>
          <para>If the expression evaluates to <code>true</code>, no error is raised.</para>
        </listitem>
      </itemizedlist>
      
      <para>The default value for the <option>assert</option> option is <code>.?status-code lt 400</code>. Since the context item is the map on the
          <port>report</port> port, <code>.</code> here refers to this map. The <code>.?status-code</code> part is one of the ways to access a map entry.
        (another way to write this is <code>.('status-code')</code>). The referred map entry contains the received (integer) HTTP status code. According to its default value, when this
        is less than <code>400</code>, the response is considered a success. If it&#x2019;s greater than <code>400</code>, it is considered a failure and
          error <step-error-ref code="XC0126"/> is raised.</para>
      
    </section>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <section xml:id="multipart">
      <title>Construction of a multipart request</title>
      <para>TBD</para>
    </section>

  </description>

  <!-- ======================================================================= -->

  <detail>
    <para>A relative value for the <option>href</option> option is resolved against the base URI of the element on which this option is specified. In
      most cases this will be the static base URI of your pipeline (the path where the XProc source containing the <step/> is stored). This is very
      probably not what you want. </para>
  </detail>

  <detail>
    <para>HTTP request header names are case-insensitive, but keys in maps are not. This means that you could specify the same request header multiple
      times in the <option>headers</option> option. For instance as <code>Content-Type</code> and <code>content-type</code>. If that happens, error
        <step-error-ref code="XC0127"/> is raised.</para>
  </detail>

  <!-- ======================================================================= -->


  <step-errors>
    <step-error code="XC0128"/>
    <step-error code="XC0122"/>
    <step-error code="XD0079"/>
    <step-error code="XC0131"/>
    <step-error code="XC0127"/>
    <step-error code="XC0123"/>
    <step-error code="XC0003"/>
    <step-error code="XC0030"/>
    <step-error code="XC0129"/>
    <step-error code="XC0125"/>
    <step-error code="XC0132"/>
    <step-error code="XC0078"/>
    <step-error code="XC0124"/>
    <step-error code="XC0126"/>
    <step-error code="XC0203"/>
    <step-error code="XC0133"/>
  </step-errors>

</step>
